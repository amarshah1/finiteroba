(set-info :smt-lib-version 2.6)
(set-logic AUFBVDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Nunchaku, Leon, CVC4, converted to v2.6 by CVC4
Application: Counterexample generation for higher-order theorem provers
Target solver: CVC4, Z3
Publications: "Model Finding for Recursive Functions in SMT" by Andrew Reynolds, Jasmin Christian Blanchette, Simon Cruanes, and Cesare Tinelli, IJCAR 2016.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-sort T!208 0)
(declare-datatypes ((List!947 0)) (((Cons!948 (h!949 T!208) (t!950 List!947)) (Nil!951))
))
(declare-fun error_value!982 () List!947)
(declare-fun error_value!988 () Int)
(declare-fun List$map!963 (List!947 (Array T!208 T!208)) List!947)
(declare-fun List$$colon$colon!964 (List!947 T!208) List!947)
(declare-fun List$size!965 (List!947) Int)
(declare-fun error_value!1000 () List!947)
(declare-sort I_List$map!963 0)
(declare-fun List$map!963_arg_0_1 (I_List$map!963) List!947)
(declare-fun List$map!963_arg_1_2 (I_List$map!963) (Array T!208 T!208))
(declare-sort I_List$$colon$colon!964 0)
(declare-fun List$$colon$colon!964_arg_0_3 (I_List$$colon$colon!964) List!947)
(declare-fun List$$colon$colon!964_arg_1_4 (I_List$$colon$colon!964) T!208)
(declare-sort I_List$size!965 0)
(declare-fun List$size!965_arg_0_5 (I_List$size!965) List!947)
(assert (forall ((?i I_List$map!963)) (and (= (List$map!963 (List$map!963_arg_0_1 ?i) (List$map!963_arg_1_2 ?i)) (ite ((_ is Nil!951) (List$map!963_arg_0_1 ?i)) Nil!951 (ite ((_ is Cons!948) (List$map!963_arg_0_1 ?i)) (List$$colon$colon!964 (List$map!963 (t!950 (List$map!963_arg_0_1 ?i)) (List$map!963_arg_1_2 ?i)) (select (List$map!963_arg_1_2 ?i) (h!949 (List$map!963_arg_0_1 ?i)))) error_value!982))) (ite ((_ is Nil!951) (List$map!963_arg_0_1 ?i)) true (ite ((_ is Cons!948) (List$map!963_arg_0_1 ?i)) (and (not (forall ((?z I_List$$colon$colon!964)) (not (and (= (List$$colon$colon!964_arg_0_3 ?z) (List$map!963 (t!950 (List$map!963_arg_0_1 ?i)) (List$map!963_arg_1_2 ?i))) (= (List$$colon$colon!964_arg_1_4 ?z) (select (List$map!963_arg_1_2 ?i) (h!949 (List$map!963_arg_0_1 ?i)))))) )) (not (forall ((?z I_List$map!963)) (not (and (= (List$map!963_arg_0_1 ?z) (t!950 (List$map!963_arg_0_1 ?i))) (= (List$map!963_arg_1_2 ?z) (List$map!963_arg_1_2 ?i)))) ))) true))) ))
(assert (forall ((?i I_List$$colon$colon!964)) (= (List$$colon$colon!964 (List$$colon$colon!964_arg_0_3 ?i) (List$$colon$colon!964_arg_1_4 ?i)) (Cons!948 (List$$colon$colon!964_arg_1_4 ?i) (List$$colon$colon!964_arg_0_3 ?i))) ))
(assert (forall ((?i I_List$size!965)) (and (= (List$size!965 (List$size!965_arg_0_5 ?i)) (ite ((_ is Nil!951) (List$size!965_arg_0_5 ?i)) 0 (ite ((_ is Cons!948) (List$size!965_arg_0_5 ?i)) (+ 1 (List$size!965 (t!950 (List$size!965_arg_0_5 ?i)))) error_value!988))) (ite ((_ is Nil!951) (List$size!965_arg_0_5 ?i)) true (ite ((_ is Cons!948) (List$size!965_arg_0_5 ?i)) (not (forall ((?z I_List$size!965)) (not (= (List$size!965_arg_0_5 ?z) (t!950 (List$size!965_arg_0_5 ?i)))) )) true))) ))
(assert (not (forall ((l!209 List!947) (f!210 (Array T!208 T!208))) (or (= (List$map!963 l!209 f!210) (ite ((_ is Nil!951) l!209) Nil!951 error_value!1000)) (forall ((?z I_List$map!963)) (not (and (= (List$map!963_arg_0_1 ?z) l!209) (= (List$map!963_arg_1_2 ?z) f!210))) )) )))
(check-sat)
(exit)

